use std::fs;
use std::path::Path;
use regex::Regex;

#[path = "src/types.rs"]
mod types;
use types as shared;

/// Extract DataLang code blocks from markdown content
fn extract_datalang_blocks(content: &str) -> Vec<(usize, String)> {
    let mut blocks = Vec::new();
    let re = Regex::new(r"(?s)```(?:datalang|rust)\s*\r?\n(.*?)\r?\n```").unwrap();
    
    for captures in re.captures_iter(content) {
        if let Some(code_match) = captures.get(1) {
            let code = code_match.as_str();
            // Only include blocks that contain DataLang syntax keywords
            if code.contains("dictionary") || code.contains("term") || 
               code.contains("import") || code.contains("datalang!") {
                let line_number = content[..code_match.start()].lines().count();
                
                // Extract content inside datalang! macro if present
                let cleaned_code = if code.contains("datalang!") {
                    extract_from_datalang_macro(code)
                } else {
                    code.to_string()
                };
                
                blocks.push((line_number, cleaned_code));
            }
        }
    }
    
    blocks
}

/// Extract DataLang syntax from inside datalang! macro blocks
fn extract_from_datalang_macro(code: &str) -> String {
    let re = Regex::new(r"(?s)datalang!\s*\{\s*(.*?)\s*\}").unwrap();
    
    if let Some(captures) = re.captures(code) {
        if let Some(inner_match) = captures.get(1) {
            return inner_match.as_str().to_string();
        }
    }
    
    code.to_string()
}

/// Validate DataLang syntax in a markdown file
fn validate_markdown_file(file_path: &Path) -> Result<Vec<String>, String> {
    let content = fs::read_to_string(file_path)
        .map_err(|e| format!("Failed to read {}: {}", file_path.display(), e))?;
    
    let blocks = extract_datalang_blocks(&content);
    let mut validated_blocks = Vec::new();
    
    for (line_num, code) in blocks {
        match shared::DataLangFile::parse_from_str(&code) {
            Ok(parsed) => {
                if let Err(validation_error) = parsed.validate() {
                    return Err(format!(
                        "{}:{} - Validation failed: {}", 
                        file_path.display(), 
                        line_num,
                        validation_error
                    ));
                }
                validated_blocks.push(format!("{}:{}", file_path.display(), line_num));
            }
            Err(parse_error) => {
                return Err(format!(
                    "{}:{} - Parse error: {}", 
                    file_path.display(), 
                    line_num,
                    parse_error
                ));
            }
        }
    }
    
    Ok(validated_blocks)
}

fn main() {
    let text_definitions_dir = "dirctionary_tests/text_definitions";
    let macro_definitions_dir = "dirctionary_tests/macro_definitions";

    // Create the macro_definitions directory if it doesn't exist
    fs::create_dir_all(macro_definitions_dir).unwrap();

    let mut validated_files = Vec::new();

    // Read all .txt files from text_definitions
    let text_dir = Path::new(text_definitions_dir);
    if text_dir.exists() && text_dir.is_dir() {
        for entry in fs::read_dir(text_dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();

            if path.extension().and_then(|s| s.to_str()) == Some("txt") {
                let file_stem = path.file_stem().unwrap().to_str().unwrap();
                let content = fs::read_to_string(&path).unwrap();

                // Validate the content before generating
                match shared::DataLangFile::parse_from_str(&content) {
                    Ok(parsed) => {
                        if let Err(validation_error) = parsed.validate() {
                            panic!("Validation failed for {file_stem}.txt: {validation_error}");
                        }
                        validated_files.push(file_stem.to_string());
                    }
                    Err(parse_error) => {
                        panic!("Parse error in {file_stem}.txt: {parse_error}");
                    }
                }

                // Generate the .rs file with datalang! macro wrapper
                // Add leading tab to each line of content
                let indented_content = content
                    .lines()
                    .map(|line| format!("\t{line}"))
                    .collect::<Vec<_>>()
                    .join("\n");

                let rust_content = [
                    &format!("// This file is automatically generated from {file_stem}.txt"),
                    "// DO NOT EDIT MANUALLY - your changes will be overwritten",
                    "//",
                    "// To regenerate this file:",
                    &format!("// 1. Edit {file_stem}.txt in the text_definitions/ directory"),
                    "// 2. Run `cargo build` or `cargo check` to trigger regeneration",
                    "",
                    "use datalang::datalang;",
                    "",
                    "datalang! {",
                    &indented_content,
                    "}",
                    "",
                ]
                .join("\n");

                let output_path = Path::new(macro_definitions_dir).join(format!("{file_stem}.rs"));

                // Only write if the content is different or file doesn't exist
                let should_write = if output_path.exists() {
                    match fs::read_to_string(&output_path) {
                        Ok(existing_content) => existing_content != rust_content,
                        Err(_) => true,
                    }
                } else {
                    true
                };

                if should_write {
                    fs::write(&output_path, rust_content).unwrap();
                }

                println!("cargo:rerun-if-changed={}", path.display());
                // Also track the generated file
                println!("cargo:rerun-if-changed={}", output_path.display());
            }
        }
    }

    // Validate DataLang syntax in markdown documentation files
    let mut markdown_validated = Vec::new();
    let markdown_files = ["README.md", "syntax.md"];
    
    for &md_file in &markdown_files {
        let md_path = Path::new(md_file);
        if md_path.exists() {
            match validate_markdown_file(md_path) {
                Ok(blocks) => {
                    if !blocks.is_empty() {
                        markdown_validated.extend(blocks);
                    }
                }
                Err(error) => {
                    panic!("DataLang syntax validation failed in {md_file}: {error}");
                }
            }
            println!("cargo:rerun-if-changed={md_file}");
        }
    }

    // Print validation summary
    if !validated_files.is_empty() {
        let checkmarks: String = validated_files
            .iter()
            .map(|file| format!("âœ“ {file}.txt"))
            .collect::<Vec<_>>()
            .join(" ");
        println!("cargo:warning=DataLang: Validated {checkmarks} files");
    }
    
    if !markdown_validated.is_empty() {
        let md_count = markdown_validated.len();
        println!("cargo:warning=DataLang: Validated {md_count} code blocks in documentation");
    }

    // Rerun if the text_definitions directory changes
    println!("cargo:rerun-if-changed={text_definitions_dir}");
    println!("cargo:rerun-if-changed=build.rs");
}
