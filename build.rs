use std::fs;
use std::path::Path;

mod shared;

fn main() {
    let text_definitions_dir = "dirctionary_tests/text_definitions";
    let macro_definitions_dir = "dirctionary_tests/macro_definitions";
    
    // Create the macro_definitions directory if it doesn't exist
    fs::create_dir_all(macro_definitions_dir).unwrap();
    
    // Read all .txt files from text_definitions
    let text_dir = Path::new(text_definitions_dir);
    if text_dir.exists() && text_dir.is_dir() {
        for entry in fs::read_dir(text_dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            
            if path.extension().and_then(|s| s.to_str()) == Some("txt") {
                let file_stem = path.file_stem().unwrap().to_str().unwrap();
                let content = fs::read_to_string(&path).unwrap();
                
                // Validate the content before generating
                println!("cargo:warning=Validating {}.txt", file_stem);
                match shared::DataLangFile::parse_from_str(&content) {
                    Ok(parsed) => {
                        if let Err(validation_error) = parsed.validate() {
                            panic!("Validation failed for {}.txt: {}", file_stem, validation_error);
                        }
                        println!("cargo:warning=âœ“ {}.txt is valid", file_stem);
                    }
                    Err(parse_error) => {
                        panic!("Parse error in {}.txt: {}", file_stem, parse_error);
                    }
                }
                
                // Generate the .rs file with datalang! macro wrapper
                // Add leading tab to each line of content
                let indented_content = content
                    .lines()
                    .map(|line| format!("\t{}", line))
                    .collect::<Vec<_>>()
                    .join("\n");
                
                let rust_content = format!(
                    "// This file is automatically generated from {}.txt\n// DO NOT EDIT MANUALLY - your changes will be overwritten\n// Edit the corresponding .txt file in text_definitions/ instead\n\nuse datalang::datalang;\n\ndatalang! {{\n{}\n}}\n",
                    file_stem,
                    indented_content
                );
                
                let output_path = Path::new(macro_definitions_dir).join(format!("{}.rs", file_stem));
                
                // Only write if the content is different or file doesn't exist
                let should_write = if output_path.exists() {
                    match fs::read_to_string(&output_path) {
                        Ok(existing_content) => existing_content != rust_content,
                        Err(_) => true,
                    }
                } else {
                    true
                };
                
                if should_write {
                    fs::write(&output_path, rust_content).unwrap();
                    println!("cargo:warning=Generated {}", output_path.display());
                }
                
                println!("cargo:rerun-if-changed={}", path.display());
                // Also track the generated file
                println!("cargo:rerun-if-changed={}", output_path.display());
            }
        }
    }
    
    // Rerun if the text_definitions directory changes
    println!("cargo:rerun-if-changed={}", text_definitions_dir);
    println!("cargo:rerun-if-changed=build.rs");
}