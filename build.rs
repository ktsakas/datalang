use std::fs;
use std::path::Path;

#[path = "src/types.rs"]
mod types;
use types as shared;

fn main() {
    let text_definitions_dir = "dirctionary_tests/text_definitions";
    let macro_definitions_dir = "dirctionary_tests/macro_definitions";
    
    // Create the macro_definitions directory if it doesn't exist
    fs::create_dir_all(macro_definitions_dir).unwrap();
    
    let mut validated_files = Vec::new();
    
    // Read all .txt files from text_definitions
    let text_dir = Path::new(text_definitions_dir);
    if text_dir.exists() && text_dir.is_dir() {
        for entry in fs::read_dir(text_dir).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            
            if path.extension().and_then(|s| s.to_str()) == Some("txt") {
                let file_stem = path.file_stem().unwrap().to_str().unwrap();
                let content = fs::read_to_string(&path).unwrap();
                
                // Validate the content before generating
                match shared::DataLangFile::parse_from_str(&content) {
                    Ok(parsed) => {
                        if let Err(validation_error) = parsed.validate() {
                            panic!("Validation failed for {}.txt: {}", file_stem, validation_error);
                        }
                        validated_files.push(file_stem.to_string());
                    }
                    Err(parse_error) => {
                        panic!("Parse error in {}.txt: {}", file_stem, parse_error);
                    }
                }
                
                // Generate the .rs file with datalang! macro wrapper
                // Add leading tab to each line of content
                let indented_content = content
                    .lines()
                    .map(|line| format!("\t{}", line))
                    .collect::<Vec<_>>()
                    .join("\n");
                
                let rust_content = [
                    &format!("// This file is automatically generated from {}.txt", file_stem),
                    "// DO NOT EDIT MANUALLY - your changes will be overwritten",
                    "//",
                    "// To regenerate this file:",
                    &format!("// 1. Edit {}.txt in the text_definitions/ directory", file_stem),
                    "// 2. Run `cargo build` or `cargo check` to trigger regeneration",
                    "",
                    "use datalang::datalang;",
                    "",
                    "datalang! {",
                    &indented_content,
                    "}",
                    "",
                ].join("\n");
                
                let output_path = Path::new(macro_definitions_dir).join(format!("{}.rs", file_stem));
                
                // Only write if the content is different or file doesn't exist
                let should_write = if output_path.exists() {
                    match fs::read_to_string(&output_path) {
                        Ok(existing_content) => existing_content != rust_content,
                        Err(_) => true,
                    }
                } else {
                    true
                };
                
                if should_write {
                    fs::write(&output_path, rust_content).unwrap();
                }
                
                println!("cargo:rerun-if-changed={}", path.display());
                // Also track the generated file
                println!("cargo:rerun-if-changed={}", output_path.display());
            }
        }
    }
    
    // Print validation summary
    if !validated_files.is_empty() {
        let checkmarks: String = validated_files.iter()
            .map(|file| format!("âœ“ {}.txt", file))
            .collect::<Vec<_>>()
            .join(" ");
        println!("cargo:warning=DataLang: Validated {} files", checkmarks);
    }
    
    // Rerun if the text_definitions directory changes
    println!("cargo:rerun-if-changed={}", text_definitions_dir);
    println!("cargo:rerun-if-changed=build.rs");
}